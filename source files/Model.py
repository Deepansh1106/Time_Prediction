# -*- coding: utf-8 -*-
"""Food_Delivery_Time_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/Deepansh1106/Deepansh1106/blob/main/Food_Delivery_Time_Prediction.ipynb

***Importing important Libraries***
"""

import pandas as pd
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
import statistics
import pickle
from geopy.distance import geodesic


from sklearn.model_selection import train_test_split,cross_val_score, GridSearchCV
from sklearn.preprocessing import LabelEncoder,StandardScaler
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb
from sklearn.metrics import mean_squared_error, r2_score,mean_absolute_error
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('ZomatoModel.csv')

"""Data Preprocessing and Analysis"""

df.head()

df.info()

df.shape

df.isnull().sum()

df.describe()

df.columns

"""**We are going to add these columns: ('Time_taken(min)', 'Weather_conditions', 'City_code') to get the meaningful data in efficient way.**

"""

def extract_column_value(df):
    # Ensure 'Time_taken(min)' is a string and then convert to int
    df['Time_taken'] = df['Time_taken(min)'].apply(lambda x: int(str(x).split(' ')[1].strip()) if isinstance(x, str) else x)

    # Ensure 'Weatherconditions' is a string before splitting
    df['Weather_conditions'] = df['Weatherconditions'].apply(lambda x: str(x).split(' ')[1].strip() if isinstance(x, str) else x)

    # Ensure 'Delivery_person_ID' is a string before splitting
    df['City_code'] = df['Delivery_person_ID'].astype(str).str.split("RES", expand=True)[0]

    return df  # <-- IMPORTANT

# Call the function and capture the result
df = extract_column_value(df)

# Now safely drop unneeded columns
df.drop(['Weatherconditions', 'ID', 'Delivery_person_ID'], axis=1, inplace=True)

# Check the result
df.head()

df.head()

df.columns

df.duplicated()

df['Delivery_person_Age'] = df['Delivery_person_Age'].astype('float64')
df['Delivery_person_Ratings'] = df['Delivery_person_Ratings'].astype('float64')
df['multiple_deliveries'] = df['multiple_deliveries'].astype('float64')
df['Order_Date']=pd.to_datetime(df['Order_Date'],format="%d-%m-%Y")

df.replace('NaN', float(np.nan), inplace=True)

df.info()

df.isnull().sum().sort_values(ascending=False)

#handle null values
df['Delivery_person_Age'].fillna(np.random.choice(df['Delivery_person_Age']), inplace=True)
df['Weather_conditions'].fillna(np.random.choice(df['Weather_conditions']), inplace=True)
df['City'].fillna(df['City'].mode()[0], inplace=True)
df['Festival'].fillna(df['Festival'].mode()[0], inplace=True)
df['multiple_deliveries'].fillna(df['multiple_deliveries'].mode()[0], inplace=True)
df['Road_traffic_density'].fillna(df['Road_traffic_density'].mode()[0], inplace=True)
df['Delivery_person_Ratings'].fillna(df['Delivery_person_Ratings'].median(), inplace=True)

"""**Time Series Analysis**"""

df["day"] = df.Order_Date.dt.day
df["month"] = df.Order_Date.dt.month
df["quarter"] = df.Order_Date.dt.quarter
df["year"] = df.Order_Date.dt.year
df['day_of_week'] = df.Order_Date.dt.day_of_week.astype(int)
df["is_month_start"] = df.Order_Date.dt.is_month_start.astype(int)
df["is_month_end"] = df.Order_Date.dt.is_month_end.astype(int)
df["is_quarter_start"] = df.Order_Date.dt.is_quarter_start.astype(int)
df["is_quarter_end"] = df.Order_Date.dt.is_quarter_end.astype(int)
df["is_year_start"] = df.Order_Date.dt.is_year_start.astype(int)
df["is_year_end"] = df.Order_Date.dt.is_year_end.astype(int)
df['is_weekend'] = np.where(df['day_of_week'].isin([5,6]),1,0)

df.head()

df.isnull().sum()

print(df['Time_Orderd'].unique())

mask = df['Time_Orderd'].isna()
mask[mask==True]

# Convert to timedelta (also handles 'NaN' or invalid formats as NaT)
df['Time_Orderd'] = pd.to_timedelta(df['Time_Orderd'], errors='coerce')

# Now fill the NaNs using the median of timedelta values
df['Time_Orderd'].fillna(df['Time_Orderd'].median(), inplace=True)

mask = df['Time_Orderd'].isna()
mask[mask==True]





# Convert Order_Date to datetime if it's not already
df['Order_Date'] = pd.to_datetime(df['Order_Date'])

# Convert the 'Time_Orderd' and 'Time_Order_picked' columns to timedelta (duration)
df['Time_Orderd'] = pd.to_timedelta(df['Time_Orderd'])
df['Time_Order_picked'] = pd.to_timedelta(df['Time_Order_picked'])

# Create formatted time columns as datetime objects
df['Time_Ordered_formatted'] = df['Order_Date'] + df['Time_Orderd']

df['Time_Order_picked_formatted'] = df['Order_Date'] + np.where(
    df['Time_Order_picked'] < df['Time_Orderd'],
    pd.DateOffset(days=1),
    pd.DateOffset(days=0)) + df['Time_Order_picked']

# Make sure that the new columns are of datetime type
df['Time_Ordered_formatted'] = pd.to_datetime(df['Time_Ordered_formatted'])
df['Time_Order_picked_formatted'] = pd.to_datetime(df['Time_Order_picked_formatted'])

# Now calculate the order preparation time in minutes
df['order_prepare_time'] = (df['Time_Order_picked_formatted'] - df['Time_Ordered_formatted']).dt.total_seconds() / 60

# Handle null values by filling with the median
df['order_prepare_time'].fillna(df['order_prepare_time'].median(), inplace=True)

# Check the first few rows
df[['Time_Ordered_formatted', 'Time_Order_picked_formatted', 'order_prepare_time']].head()

df.drop(['Time_Orderd', 'Time_Order_picked', 'Time_Ordered_formatted', 'Time_Order_picked_formatted', 'Order_Date','Time_taken'], axis=1, inplace=True)

# Initialize the 'distance' column with zeros
df['distance'] = np.zeros(len(df))

# Get the restaurant and delivery location coordinates as numpy arrays
restaurant_coordinates = df[['Restaurant_latitude', 'Restaurant_longitude']].to_numpy()
delivery_location_coordinates = df[['Delivery_location_latitude', 'Delivery_location_longitude']].to_numpy()

# Calculate the geodesic distance between each restaurant and delivery location
df['distance'] = np.array([
    geodesic(restaurant, delivery).kilometers
    for restaurant, delivery in zip(restaurant_coordinates, delivery_location_coordinates)
])

df = df[df['distance'] < 100]  # âœ… Completely overwrite with filtered rows

df['distance'].head()

df.shape

df['distance'].describe()

"""**DATA VISUALIZATION**"""

df_sorted = df.sort_values(by='Time_taken(min)', ascending=True)

# Plot the distribution using the sorted dataframe
plt.figure(figsize=(20, 6))
sns.histplot(df_sorted['Time_taken(min)'], kde=True, color='blue')
plt.title('Distribution of Delivery Time (Minutes)')
plt.xlabel('Delivery Time (Minutes)')
plt.ylabel('Frequency')
plt.xticks(rotation=45)
plt.locator_params(axis='x', nbins=10)
plt.show()

df.columns

#df['distance'] = np.zeros(len(df))
#restaurant_coordinates = df[['Restaurant_latitude', 'Restaurant_longitude']].to_numpy()
#delivery_location_coordinates = df[['Delivery_location_latitude', 'Delivery_location_longitude']].to_numpy()

# Calculate distances
#df['distance'] = np.array([geodesic(restaurant, delivery).km for restaurant, delivery in zip(restaurant_coordinates, delivery_location_coordinates)])

# Scatter Plot
plt.figure(figsize=(10, 10))
sns.scatterplot(x='distance', y='Time_taken(min)', data=df, hue='Delivery_person_Ratings', size='Delivery_person_Age', sizes=(20, 200), alpha=0.6)
plt.title('Relationship Between Distance and Time Taken')
plt.xlabel('Distance (km)')
plt.ylabel('Time Taken (Minutes)')
plt.show()

plt.figure(figsize=(12, 10))
sns.boxplot(x='Delivery_person_Age', y='Time_taken(min)', data=df, orient= 'v')
plt.title('Delivery Time across Different Age Groups')
plt.ylabel('Age of Delivery Partner')
plt.xlabel('Time Taken (Minutes)')
plt.show()

# Countplot of Delivery Partners' Age
plt.figure(figsize=(8, 6))
sns.countplot(x='Delivery_person_Age', data=df)
plt.title('Count of Delivery Partners by Age')
plt.xlabel('Age of Delivery Partner')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

# Dictionary to map the weather conditions to human-readable labels
weather_mapping = {
    0: 'Clear',
    1: 'Partly Cloudy',
    2: 'Cloudy',
    3: 'Light Rain',
    4: 'Heavy Rain',
    5: 'Storm'
}

# Create the bar plot with count of weather conditions
plt.figure(figsize=(10, 6))
sns.countplot(x='Weather_conditions', data=df, palette='coolwarm')

# Adding title and labels
plt.title('Weather Conditions During Deliveries')
plt.xlabel('Weather Conditions')
plt.ylabel('Count')
# Annotating the weather condition labels on the x-axis
for index, label in weather_mapping.items():
    plt.text(index, 50, label, horizontalalignment='center', fontsize=10, color='black')



plt.show()

# Creating the boxplot
plt.figure(figsize=(10, 10))
sns.boxplot(x='Weather_conditions', y='Time_taken(min)', data=df, palette="coolwarm")

# Adding title and labels
plt.title('Impact of Weather Conditions on Delivery Time')
plt.xlabel('Weather Conditions')
plt.ylabel('Delivery Time (Minutes)')



plt.xticks(rotation=45)
plt.show()

# Countplot - Deliveries During Festival Days
plt.figure(figsize=(10, 6))
sns.countplot(x='Festival', data=df, palette='spring')
plt.title('Deliveries During Festival and Non-Festival Days')
plt.xlabel('Festival Day?')
plt.ylabel('Count')
plt.show()

# Countplot - Road Traffic Density During Deliveries
plt.figure(figsize=(10, 6))
sns.countplot(x='Road_traffic_density', data=df, palette='RdYlGn')
plt.title('Road Traffic Density During Deliveries')
plt.xlabel('Traffic Density')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

"""**LABEL ENCODING**"""

# Apply Label Encoding as before
categorical_columns = df.select_dtypes(include='object').columns
label_encoder = LabelEncoder()
df[categorical_columns] = df[categorical_columns].apply(lambda col: label_encoder.fit_transform(col))

# Display first few rows of the DataFrame with encoded values
print(df[categorical_columns].head())

"""**TRAIN TEST SPLIT**"""

df.columns

#Split features & label
X = df.drop(['Time_taken(min)','Type_of_order', 'Type_of_vehicle',
       'multiple_deliveries','City_code',
       'order_prepare_time', 'Restaurant_latitude',
       'Restaurant_longitude', 'Delivery_location_latitude',
       'Delivery_location_longitude','Vehicle_condition','City','Road_traffic_density'], axis=1)   # Features
y = df['Time_taken(min)']  # Target variable

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
print(X_train.shape)
print(y_train.shape)
print(X_test.shape)
print(y_test.shape)

X.columns

X.shape

print(y.shape)

print(df.dtypes[['Delivery_person_Age', 'Time_taken(min)', 'distance']])

scaler=StandardScaler()
X_train=scaler.fit_transform(X_train)
X_test=scaler.transform(X_test)

from sklearn.model_selection import GridSearchCV, cross_val_score
from sklearn.ensemble import RandomForestRegressor
import xgboost as xgb

# Find the best model
models = [
    RandomForestRegressor(),
    xgb.XGBRegressor(),
]

param_grid = [
    {'n_estimators': [100, 200, 300]},
    {'n_estimators': [20, 25, 30], 'max_depth': [5, 7, 9]},
]

for i, model in enumerate(models):
    grid_search = GridSearchCV(model, param_grid[i], cv=5, scoring='r2',n_jobs=-1,verbose=1)
    grid_search.fit(X_train, y_train)

    print(f"{model.__class__.__name__}:")
    print("Best parameters:", grid_search.best_params_)
    print("Best R2 score:", grid_search.best_score_)
    print()

# Create a XGB regressor model
model = xgb.XGBRegressor(n_estimators=20,max_depth=9)

# Fit the model on the training data
model.fit(X_train, y_train)

# Make predictions on the test data
y_pred = model.predict(X_test)

# Evaluate the model
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print("Mean Absolute Error (MAE):", round(mae,2))
print("Mean Squared Error (MSE):", round(mse,2))
print("Root Mean Squared Error (RMSE):", round(rmse,2))
print("R-squared (R2) Score:", round(r2,2))

import pickle
import numpy as np
from datetime import datetime

def month_end_day(date):
    from calendar import monthrange
    return monthrange(date.year, date.month)[1]

def get_user_input():
    # Numerical inputs
    age = float(input("Enter Age of Delivery Partner: "))
    rating = float(input("Enter Delivery Partner's Average Rating (e.g., 4.5): "))
    distance = float(input("Enter Total Distance (in km): "))

    festival = input("Is there a Festival? (Yes/No): ").strip().lower()
    weather = input("Enter Weather Condition (Sunny/Stormy/Cloudy/Fog/Windy): ").strip().capitalize()
    date_str = input("Enter Delivery Date (YYYY-MM-DD): ")
    delivery_date = datetime.strptime(date_str, "%Y-%m-%d")

    input_array = np.zeros((1, 17))  # 17 features
    input_array[0, 0] = age
    input_array[0, 1] = rating
    input_array[0, 4] = distance
    input_array[0, 2] = 1 if festival == "yes" else 0

    weather_map = {'Sunny': 0, 'Stormy': 1, 'Cloudy': 2, 'Fog': 3, 'Windy': 4}
    input_array[0, 3] = weather_map.get(weather, 0)

    input_array[0, 5] = delivery_date.day
    input_array[0, 6] = delivery_date.month
    input_array[0, 7] = (delivery_date.month - 1) // 3 + 1
    input_array[0, 8] = delivery_date.year
    input_array[0, 9] = delivery_date.weekday()
    input_array[0, 10] = 1 if delivery_date.day == 1 else 0
    input_array[0, 11] = 1 if delivery_date.day == month_end_day(delivery_date) else 0
    input_array[0, 12] = 1 if delivery_date.month in [1, 4, 7, 10] and delivery_date.day == 1 else 0
    input_array[0, 13] = 1 if delivery_date.month in [3, 6, 9, 12] and delivery_date.day == month_end_day(delivery_date) else 0
    input_array[0, 14] = 1 if delivery_date.month == 1 and delivery_date.day == 1 else 0
    input_array[0, 15] = 1 if delivery_date.month == 12 and delivery_date.day == 31 else 0
    input_array[0, 16] = 1 if delivery_date.weekday() >= 5 else 0

    return input_array



features = get_user_input()
predicted = model.predict(features)
print("\nðŸ“¦ Predicted Delivery Time (in Minutes):", round(predicted[0], 2))

import pickle

# Assuming 'model' is your trained model
with open('delivery_time_model.pkl', 'wb') as f:
    pickle.dump(model, f)

print("âœ… Model saved successfully as 'delivery_time_model.pkl'")